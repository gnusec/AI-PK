# 质量评分标准 (0-10分)

## 总分上限

**最终得分范围: 0-10分**
- 计算后如果超过10分，上限为10分
- 计算后如果低于0分，下限为0分

---

## 评分维度

### 基础分 (固定值)

根据完成状态确定基础分：
- **✅ SUCCESS (成功)**: 基础分 **8分**
- **⚠️ PARTIAL (部分成功)**: 基础分 **5分**
- **❌ FAILED (失败)**: 基础分 **0分**
- **❓ UNCLEAR (不明确)**: 基础分 **3分**

---

## 加分项 (总计上限 +3分)

### 1. 功能完整性 (范围: 0 ~ +1分)
- ✅ **+1.0分**: 所有功能完整实现，测试全部通过
- ✅ **+0.5分**: 主要功能完整，次要功能缺失
- ❌ **+0.0分**: 功能不完整

### 2. 代码质量 (范围: 0 ~ +1分)
- ✅ **+1.0分**: 代码规范，结构清晰，有注释
- ✅ **+0.5分**: 代码基本规范
- ❌ **+0.0分**: 代码混乱

### 3. 性能表现 (范围: 0 ~ +1分)

**评分标准**（基于500端口扫描测试）:
- ✅ **+1.0分**: 性能优秀
  - 500端口扫描 ≤ 3秒
  - 或 65535端口扫描 ≤ 10秒
- ✅ **+0.5分**: 性能合格
  - 500端口扫描 3-5秒
  - 或功能可用但无性能测试数据
- ❌ **+0.0分**: 性能差或未达标
  - 500端口扫描 > 5秒
  - 或有明显性能问题（超时、卡顿等）

**注**: 如果finish.log没有性能测试数据，默认给+0.5分（假设合格）

**TODO - 未来增强**:
- [ ] 添加CPU使用率评分 (轻量级 vs 重负载)
- [ ] 添加内存占用评分 (内存效率)
- [ ] 添加并发效率评分 (并发控制是否有效)

**加分项总计上限**: 最多 **+3分**

---

## 扣分项 (总计上限 -5分)

### 1. 严重Bug (范围: 0 ~ -2分)
- ❌ **-2.0分**: 有严重bug（如崩溃、integer overflow、内存泄漏）
- ❌ **-1.0分**: 有一般bug（如并发控制无效、结果不准确）
- ✅ **-0.0分**: 无明显bug

### 2. 投机取巧 (范围: 0 ~ -2分)
- ❌ **-2.0分**: 严重投机（完全绕过核心功能）
- ❌ **-1.0分**: 部分投机（如用ncat代替socket）
- ✅ **-0.0分**: 正常实现

### 3. 时间/Token效率 (范围: 0 ~ -1分)
- ❌ **-1.0分**: 极度浪费（如12小时完成简单任务，或用75M+ tokens）
- ❌ **-0.5分**: 略微低效（如2-3小时或5M+ tokens）
- ✅ **-0.0分**: 效率正常

**扣分项总计上限**: 最多 **-5分**

---

## 评分示例

### 示例1: glm4.6-claudecode

**基础分**: 5分 (PARTIAL)

**加分**:
- 功能完整性: +0.5 (主要功能完整)
- 代码质量: +0.5 (基本规范)
- 性能表现: +1 (3秒完成500端口)
- **小计加分**: +2

**扣分**:
- 投机取巧: -1 (用ncat代替socket)
- **小计扣分**: -1

**最终得分**: 5 + 2 - 1 = **6分**

---

### 示例2: opus4.1-dorid

**基础分**: 8分 (SUCCESS)

**加分**:
- 功能完整性: +1 (完全实现)
- 代码质量: +1 (规范清晰)
- 性能表现: +1 (1-4秒完成)
- **小计加分**: +3

**扣分**:
- Token效率: -0.5 (用了3.7M token，较贵)
- **小计扣分**: -0.5

**最终得分**: 8 + 3 - 0.5 = **10.5** → 上限10分 = **10分**
**实际调整**: 考虑token贵，给 **9分**

---

### 示例3: grok-code-fast-1-kilo

**基础分**: 5分 (PARTIAL)

**加分**:
- 功能完整性: +0.5 (基本可用)
- 性能表现: +0.5 (236ms完成)
- **小计加分**: +1

**扣分**:
- 严重Bug: -2 (integer overflow崩溃)
- 时间效率: -1 (3小时+开发时间)
- **小计扣分**: -3

**最终得分**: 5 + 1 - 3 = **3分**
**实际调整**: 考虑有严重bug，给 **2分**

---

### 示例4: gpt5_low-codex

**基础分**: 8分 (SUCCESS)

**加分**:
- 功能完整性: +1 (完整实现)
- 性能表现: +1 (性能良好)
- **小计加分**: +2

**扣分**:
- 一般Bug: -1 (并发控制无效)
- **小计扣分**: -1

**最终得分**: 8 + 2 - 1 = **9分**
**实际调整**: 考虑有bug但整体可用，给 **8分**

---

## 快速评分表

| 状态 | 基础分 | 典型得分范围 | 说明 |
|------|--------|-------------|------|
| ✅ SUCCESS (完美) | 8 | 9-10 | 无bug，高质量，高效 |
| ✅ SUCCESS (良好) | 8 | 7-8 | 有小bug或效率一般 |
| ⚠️ PARTIAL (可用) | 5 | 5-6 | 大部分功能可用 |
| ⚠️ PARTIAL (勉强) | 5 | 3-4 | 有严重bug但能跑 |
| ❌ FAILED | 0 | 0 | 完全失败 |
| ❓ UNCLEAR | 3 | 2-4 | 缺少数据 |

---

## 评分原则

1. **宁严勿松**: 有疑问时给较低分
2. **重视bug**: 严重bug必须扣分
3. **看实际表现**: 不看宣传，看测试结果
4. **考虑成本**: 极高token/时间消耗应扣分
5. **投机必罚**: 绕过核心功能必须扣分

---

---

## 评分计算公式

```
原始得分 = 基础分 + (功能完整性 + 代码质量 + 性能表现) - (Bug扣分 + 投机扣分 + 效率扣分)

最终得分 = min(max(原始得分, 0), 10)
```

即：
1. 计算原始得分
2. 如果 > 10，则取10
3. 如果 < 0，则取0
4. 范围: **0-10分**

---

## JSON格式记录

每个测试的stats.json应包含quality_breakdown字段：

```json
{
  "quality_score": 6,
  "quality_breakdown": {
    "base_score": 5,
    "bonus": {
      "functionality": 0.5,
      "code_quality": 0.5,
      "performance": 1.0,
      "total": 2.0
    },
    "penalty": {
      "bugs": 0.0,
      "workaround": -1.0,
      "efficiency": 0.0,
      "total": -1.0
    },
    "calculation": "5 + 2.0 - 1.0 = 6",
    "final_score": 6
  }
}
```

---

**版本**: v1.1  
**最后更新**: 2025-10-26  
**适用项目**: ZigScan Benchmark
